const fs = require('fs').promises;
const path = require('path');

/**
 * ContentFormatter class handles content formatting and export capabilities
 * Supports PDF, DOCX, and TXT formats
 */
class ContentFormatter {
    constructor() {
        this.supportedFormats = ['pdf', 'docx', 'txt', 'html'];
        this.exportDirectory = path.join(__dirname, '..', 'exports');
        this.ensureExportDirectory();
    }

    /**
     * Ensure export directory exists
     */
    async ensureExportDirectory() {
        try {
            await fs.access(this.exportDirectory);
        } catch (error) {
            await fs.mkdir(this.exportDirectory, { recursive: true });
        }
    }

    /**
     * Format content for export
     * @param {string} content - The content to format
     * @param {string} format - Export format (pdf, docx, txt, html)
     * @param {Object} options - Formatting options
     * @returns {Object} Formatted content information
     */
    async formatContent(content, format, options = {}) {
        if (!this.supportedFormats.includes(format.toLowerCase())) {
            throw new Error(`Unsupported format: ${format}. Supported formats: ${this.supportedFormats.join(', ')}`);
        }

        const formatMethod = `format${format.toUpperCase()}`;
        if (typeof this[formatMethod] !== 'function') {
            throw new Error(`Format method not implemented: ${formatMethod}`);
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = options.filename || `content_${timestamp}.${format}`;
        const filepath = path.join(this.exportDirectory, filename);

        const formattedContent = await this[formatMethod](content, options);
        
        return {
            content: formattedContent,
            filename,
            filepath,
            format,
            size: Buffer.byteLength(formattedContent, 'utf8'),
            timestamp: new Date().toISOString()
        };
    }

    /**
     * Format content as plain text
     * @param {string} content - Content to format
     * @param {Object} options - Formatting options
     * @returns {string} Formatted text content
     */
    async formatTXT(content, options = {}) {
        const {
            lineWidth = 80,
            includeHeader = true,
            includeFooter = true,
            title = 'Generated Content'
        } = options;

        let formattedContent = '';

        // Add header
        if (includeHeader) {
            const headerLine = '='.repeat(lineWidth);
            formattedContent += `${headerLine}\n`;
            formattedContent += `${title.toUpperCase().padStart((lineWidth + title.length) / 2)}\n`;
            formattedContent += `Generated on: ${new Date().toLocaleString()}\n`;
            formattedContent += `${headerLine}\n\n`;
        }

        // Add content with word wrapping
        const wrappedContent = this.wrapText(content, lineWidth);
        formattedContent += wrappedContent;

        // Add footer
        if (includeFooter) {
            const footerLine = '-'.repeat(lineWidth);
            formattedContent += `\n\n${footerLine}\n`;
            formattedContent += `Word Count: ${this.countWords(content)}\n`;
            formattedContent += `Character Count: ${content.length}\n`;
            formattedContent += `Generated by AssignSavvy AI Writer\n`;
        }

        return formattedContent;
    }

    /**
     * Format content as HTML
     * @param {string} content - Content to format
     * @param {Object} options - Formatting options
     * @returns {string} Formatted HTML content
     */
    async formatHTML(content, options = {}) {
        const {
            title = 'Generated Content',
            includeCSS = true,
            theme = 'default'
        } = options;

        const css = includeCSS ? this.getHTMLCSS(theme) : '';
        const paragraphs = content.split('\n\n').map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('\n');

        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    ${css ? `<style>${css}</style>` : ''}
</head>
<body>
    <div class="container">
        <header>
            <h1>${title}</h1>
            <p class="meta">Generated on ${new Date().toLocaleString()}</p>
        </header>
        <main>
            ${paragraphs}
        </main>
        <footer>
            <p>Word Count: ${this.countWords(content)} | Character Count: ${content.length}</p>
            <p>Generated by AssignSavvy AI Writer</p>
        </footer>
    </div>
</body>
</html>`;
    }

    /**
     * Format content as PDF (simplified - returns HTML for PDF conversion)
     * @param {string} content - Content to format
     * @param {Object} options - Formatting options
     * @returns {string} HTML content ready for PDF conversion
     */
    async formatPDF(content, options = {}) {
        const {
            title = 'Generated Content',
            fontSize = '12pt',
            fontFamily = 'Times New Roman',
            margin = '1in'
        } = options;

        const pdfCSS = `
            @page {
                margin: ${margin};
                size: A4;
            }
            body {
                font-family: ${fontFamily};
                font-size: ${fontSize};
                line-height: 1.6;
                color: #333;
            }
            .container {
                max-width: 100%;
            }
            h1 {
                text-align: center;
                margin-bottom: 20px;
                border-bottom: 2px solid #333;
                padding-bottom: 10px;
            }
            .meta {
                text-align: center;
                font-style: italic;
                margin-bottom: 30px;
            }
            p {
                text-align: justify;
                margin-bottom: 15px;
            }
            footer {
                margin-top: 30px;
                border-top: 1px solid #ccc;
                padding-top: 10px;
                font-size: 10pt;
                text-align: center;
            }
        `;

        const paragraphs = content.split('\n\n').map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`).join('\n');

        return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <style>${pdfCSS}</style>
</head>
<body>
    <div class="container">
        <h1>${title}</h1>
        <p class="meta">Generated on ${new Date().toLocaleString()}</p>
        ${paragraphs}
        <footer>
            <p>Word Count: ${this.countWords(content)} | Character Count: ${content.length}</p>
            <p>Generated by AssignSavvy AI Writer</p>
        </footer>
    </div>
</body>
</html>`;
    }

    /**
     * Format content as DOCX (simplified - returns structured data)
     * @param {string} content - Content to format
     * @param {Object} options - Formatting options
     * @returns {Object} Structured data for DOCX generation
     */
    async formatDOCX(content, options = {}) {
        const {
            title = 'Generated Content',
            fontSize = 12,
            fontFamily = 'Times New Roman'
        } = options;

        const paragraphs = content.split('\n\n').map(p => ({
            type: 'paragraph',
            text: p.replace(/\n/g, ' '),
            formatting: {
                fontSize,
                fontFamily,
                alignment: 'justify'
            }
        }));

        return {
            title,
            metadata: {
                creator: 'AssignSavvy AI Writer',
                created: new Date().toISOString(),
                wordCount: this.countWords(content),
                characterCount: content.length
            },
            content: [
                {
                    type: 'heading',
                    text: title,
                    level: 1,
                    formatting: {
                        fontSize: fontSize + 4,
                        fontFamily,
                        alignment: 'center',
                        bold: true
                    }
                },
                {
                    type: 'paragraph',
                    text: `Generated on ${new Date().toLocaleString()}`,
                    formatting: {
                        fontSize: fontSize - 1,
                        fontFamily,
                        alignment: 'center',
                        italic: true
                    }
                },
                ...paragraphs,
                {
                    type: 'paragraph',
                    text: `Word Count: ${this.countWords(content)} | Character Count: ${content.length}`,
                    formatting: {
                        fontSize: fontSize - 1,
                        fontFamily,
                        alignment: 'center'
                    }
                }
            ]
        };
    }

    /**
     * Save formatted content to file
     * @param {Object} formattedResult - Result from formatContent
     * @returns {Object} File save information
     */
    async saveToFile(formattedResult) {
        try {
            await fs.writeFile(formattedResult.filepath, formattedResult.content, 'utf8');
            
            return {
                success: true,
                filename: formattedResult.filename,
                filepath: formattedResult.filepath,
                size: formattedResult.size,
                format: formattedResult.format
            };
        } catch (error) {
            throw new Error(`Failed to save file: ${error.message}`);
        }
    }

    /**
     * Get available export formats
     * @returns {Array} List of supported formats
     */
    getSupportedFormats() {
        return [...this.supportedFormats];
    }

    /**
     * Wrap text to specified width
     * @param {string} text - Text to wrap
     * @param {number} width - Line width
     * @returns {string} Wrapped text
     */
    wrapText(text, width) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';

        for (const word of words) {
            if ((currentLine + word).length <= width) {
                currentLine += (currentLine ? ' ' : '') + word;
            } else {
                if (currentLine) {
                    lines.push(currentLine);
                }
                currentLine = word;
            }
        }

        if (currentLine) {
            lines.push(currentLine);
        }

        return lines.join('\n');
    }

    /**
     * Count words in text
     * @param {string} text - Text to count
     * @returns {number} Word count
     */
    countWords(text) {
        return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }

    /**
     * Get CSS for HTML formatting
     * @param {string} theme - CSS theme
     * @returns {string} CSS styles
     */
    getHTMLCSS(theme) {
        const themes = {
            default: `
                body {
                    font-family: 'Georgia', serif;
                    line-height: 1.6;
                    color: #333;
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                }
                .container {
                    background: white;
                    padding: 40px;
                    box-shadow: 0 0 10px rgba(0,0,0,0.1);
                }
                h1 {
                    color: #2c3e50;
                    text-align: center;
                    border-bottom: 3px solid #3498db;
                    padding-bottom: 10px;
                }
                .meta {
                    text-align: center;
                    color: #7f8c8d;
                    font-style: italic;
                    margin-bottom: 30px;
                }
                p {
                    text-align: justify;
                    margin-bottom: 15px;
                }
                footer {
                    margin-top: 40px;
                    border-top: 1px solid #ecf0f1;
                    padding-top: 20px;
                    text-align: center;
                    color: #95a5a6;
                    font-size: 0.9em;
                }
            `,
            academic: `
                body {
                    font-family: 'Times New Roman', serif;
                    line-height: 1.8;
                    color: #000;
                    max-width: 750px;
                    margin: 0 auto;
                    padding: 20px;
                }
                .container {
                    background: white;
                    padding: 50px;
                }
                h1 {
                    text-align: center;
                    margin-bottom: 30px;
                    font-size: 1.5em;
                }
                .meta {
                    text-align: center;
                    margin-bottom: 40px;
                }
                p {
                    text-align: justify;
                    text-indent: 2em;
                    margin-bottom: 0;
                }
                footer {
                    margin-top: 50px;
                    text-align: center;
                    font-size: 0.8em;
                }
            `
        };

        return themes[theme] || themes.default;
    }
}

module.exports = ContentFormatter;